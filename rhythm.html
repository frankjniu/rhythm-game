<!DOCTYPE html>
<!-- Rhythm Master 3D - A WebGL-based rhythm game using Three.js and Tone.js -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rhythm Master 3D</title>
  <!-- Game styles -->
  <style>
    /* Base styles */
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Montserrat', 'Arial', sans-serif;
      background-color: #000;
    }

    /* Game container */
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Score and combo UI */
    #ui-container {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 10;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.6);
      border-radius: 10px;
      border-left: 4px solid #6200ea;
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      transition: all 0.3s;
    }

    /* Score display */
    #score {
      font-size: 28px;
      margin-bottom: 10px;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(98, 0, 234, 0.8);
    }

    /* Combo counter */
    #combo {
      font-size: 22px;
      color: #ffcc00;
      font-weight: 600;
      text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
    }

    /* Score multiplier */
    #multiplier {
      font-size: 18px;
      color: #00ffcc;
      margin-top: 8px;
      font-weight: 500;
    }

    /* Song info display */
    #song-info {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      z-index: 10;
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.6);
      border-radius: 10px;
      border-right: 4px solid #ff3e80;
      text-align: right;
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    /* Song title */
    #song-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 5px;
      color: #ff3e80;
    }

    /* Difficulty indicator */
    #difficulty {
      font-size: 16px;
      color: #ffcc00;
    }

    /* BPM display */
    #bpm {
      font-size: 14px;
      color: #00ffcc;
      margin-top: 5px;
    }

    /* Song timer */
    #timer {
      font-size: 22px;
      margin-top: 8px;
      color: white;
    }

    /* Game instructions */
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: white;
      z-index: 10;
      font-size: 16px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 12px 0;
      backdrop-filter: blur(5px);
      transition: opacity 0.5s;
    }

    /* Start screen */
    #start-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #1a0033, #000000);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: white;
      text-align: center;
    }

    /* Game title */
    #game-title {
      font-size: 60px;
      font-weight: 800;
      margin-bottom: 20px;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      filter: drop-shadow(0 0 10px rgba(98, 0, 234, 0.5));
    }

    /* Song selection area */
    #song-selection {
      margin: 20px 0 30px 0;
      width: 80%;
      max-width: 600px;
    }

    /* Option containers for song/difficulty */
    .option-container {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }

    /* Option labels */
    .option-label {
      font-size: 24px;
      margin-bottom: 10px;
      color: #ff3e80;
    }

    /* Selection options */
    .option {
      background-color: rgba(98, 0, 234, 0.3);
      padding: 10px 20px;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    /* Option hover effect */
    .option:hover {
      background-color: rgba(98, 0, 234, 0.5);
      transform: scale(1.05);
    }

    /* Selected option style */
    .option.selected {
      background-color: rgba(98, 0, 234, 0.8);
      border: 2px solid #ff3e80;
      box-shadow: 0 0 15px rgba(255, 62, 128, 0.6);
    }

    /* Start button */
    #start-button {
      padding: 15px 50px;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(98, 0, 234, 0.5);
      margin-top: 20px;
    }

    /* Start button hover effect */
    #start-button:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(98, 0, 234, 0.7);
    }

    /* Pause menu */
    #pause-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
      color: white;
      text-align: center;
      backdrop-filter: blur(10px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }

    /* Pause menu title */
    #pause-title {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 30px;
      background: linear-gradient(to right, #ff3e80, #ffcc00);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    /* Pause menu buttons */
    .pause-button {
      padding: 12px 40px;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      color: white;
      border: none;
      border-radius: 30px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.3s;
      margin: 10px 0;
      width: 200px;
    }

    /* Pause button hover effect */
    .pause-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(98, 0, 234, 0.7);
    }

    /* Results screen */
    #results-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, rgba(26, 0, 51, 0.95), rgba(0, 0, 0, 0.95));
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 90;
      color: white;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      backdrop-filter: blur(5px);
    }

    /* Results screen title */
    #results-title {
      font-size: 52px;
      font-weight: 800;
      margin-bottom: 20px;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    /* Results stats container */
    #results-stats {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
      margin: 20px 0 40px 0;
      width: 80%;
      max-width: 800px;
    }

    /* Individual stat box */
    .result-stat {
      background-color: rgba(98, 0, 234, 0.2);
      padding: 15px 25px;
      border-radius: 15px;
      text-align: center;
      flex: 1;
      min-width: 150px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      border-bottom: 3px solid #6200ea;
    }

    /* Stat value */
    .stat-value {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 5px;
    }

    /* Stat label */
    .stat-label {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
    }

    /* Final rating display */
    #rating {
      font-size: 40px;
      font-weight: 800;
      margin: 20px 0;
      text-shadow: 0 0 20px rgba(255, 62, 128, 0.8);
    }

    /* Hit feedback display */
    #hit-feedback {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      font-weight: 800;
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      z-index: 15;
      text-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
    }

    /* Hit feedback colors */
    .perfect {
      color: #00ffaa;
      text-shadow: 0 0 20px rgba(0, 255, 170, 0.8) !important;
    }

    .great {
      color: #00ccff;
      text-shadow: 0 0 20px rgba(0, 204, 255, 0.8) !important;
    }

    .good {
      color: #ffcc00;
      text-shadow: 0 0 20px rgba(255, 204, 0, 0.8) !important;
    }

    .miss {
      color: #ff4444;
      text-shadow: 0 0 20px rgba(255, 68, 68, 0.8) !important;
    }

    /* Combo popup animation */
    .combo-popup {
      position: absolute;
      font-size: 32px;
      font-weight: 800;
      color: #ffcc00;
      text-shadow: 0 0 15px rgba(255, 204, 0, 0.8);
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.3s;
      z-index: 12;
      pointer-events: none;
    }

    /* Energy bar container */
    #energy-bar-container {
      position: absolute;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      width: 50%;
      max-width: 500px;
      height: 20px;
      background-color: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    /* Energy bar fill */
    #energy-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      border-radius: 10px;
      transition: width 0.3s;
    }

    /* Special move ready indicator */
    #special-ready {
      position: absolute;
      left: 50%;
      bottom: 110px;
      transform: translateX(-50%);
      color: #ff3e80;
      font-size: 18px;
      font-weight: 700;
      text-shadow: 0 0 10px rgba(255, 62, 128, 0.8);
      opacity: 0;
      z-index: 11;
    }

    /* Particle effects */
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      opacity: 0.8;
      z-index: 5;
    }

    /* Lane indicators */
    .lane-indicator {
      position: absolute;
      bottom: 50px;
      transform: translateX(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: 700;
      color: white;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      z-index: 5;
      transition: transform 0.2s;
    }

    /* Special mode overlay */
    .special-mode-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, rgba(98, 0, 234, 0.2), transparent);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 4;
    }

    /* Pulse animation */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    /* Progress bar container */
    .progress-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 8px;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 11;
    }

    /* Progress bar fill */
    #progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #6200ea, #ff3e80);
      transition: width 0.1s linear;
    }
  </style>
</head>
<body>
  <!-- Main game container -->
  <div id="game-container">
    <!-- Score and combo display -->
    <div id="ui-container">
      <div id="score">Score: 0</div>
      <div id="combo">Combo: 0</div>
      <div id="multiplier">Multiplier: x1.0</div>
    </div>
    
    <!-- Song information display -->
    <div id="song-info">
      <div id="song-title">Loading...</div>
      <div id="difficulty">Loading...</div>
      <div id="bpm">BPM: 0</div>
      <div id="timer">00:00</div>
    </div>
    
    <!-- Hit feedback display -->
    <div id="hit-feedback"></div>

    <!-- Game instructions -->
    <div id="instructions">
      Press D, F, J, K when the notes reach the target zone. Press SPACE for Special when ready!
    </div>
    
    <!-- Energy bar for special move -->
    <div id="energy-bar-container">
      <div id="energy-bar"></div>
    </div>
    <div id="special-ready">SPECIAL READY! [SPACE]</div>
    
    <!-- Progress bar -->
    <div class="progress-container">
      <div id="progress-bar"></div>
    </div>
    
    <!-- Special mode visual effect -->
    <div class="special-mode-overlay" id="special-mode-overlay"></div>
    
    <!-- Start screen -->
    <div id="start-screen">
      <h1 id="game-title">RHYTHM MASTER 3D</h1>
      
      <!-- Song and difficulty selection -->
      <div id="song-selection">
        <div class="option-label">SELECT TRACK</div>
        <div class="option-container" id="track-options">
          <div class="option selected" data-track="synthwave">Synthwave Nights</div>
          <div class="option" data-track="electronic">Electronic Pulse</div>
          <div class="option" data-track="dubstep">Dubstep Dimension</div>
        </div>
        
        <div class="option-label">SELECT DIFFICULTY</div>
        <div class="option-container" id="difficulty-options">
          <div class="option selected" data-difficulty="easy">Easy</div>
          <div class="option" data-difficulty="medium">Medium</div>
          <div class="option" data-difficulty="hard">Hard</div>
        </div>
      </div>
      
      <button id="start-button">START GAME</button>
    </div>
    
    <!-- Pause menu -->
    <div id="pause-menu">
      <h2 id="pause-title">GAME PAUSED</h2>
      <button class="pause-button" id="resume-button">Resume</button>
      <button class="pause-button" id="restart-button">Restart</button>
      <button class="pause-button" id="quit-button">Quit</button>
    </div>
    
    <!-- Results screen -->
    <div id="results-screen">
      <h2 id="results-title">RESULTS</h2>
      
      <!-- Results statistics -->
      <div id="results-stats">
        <div class="result-stat">
          <div class="stat-value" id="result-score">0</div>
          <div class="stat-label">Score</div>
        </div>
        <div class="result-stat">
          <div class="stat-value" id="result-max-combo">0</div>
          <div class="stat-label">Max Combo</div>
        </div>
        <div class="result-stat">
          <div class="stat-value" id="result-perfect">0</div>
          <div class="stat-label">Perfect</div>
        </div>
        <div class="result-stat">
          <div class="stat-value" id="result-great">0</div>
          <div class="stat-label">Great</div>
        </div>
        <div class="result-stat">
          <div class="stat-value" id="result-good">0</div>
          <div class="stat-label">Good</div>
        </div>
        <div class="result-stat">
          <div class="stat-value" id="result-miss">0</div>
          <div class="stat-label">Miss</div>
        </div>
      </div>
      
      <div id="rating">S RANK</div>
      
      <button class="pause-button" id="play-again-button">Play Again</button>
      <button class="pause-button" id="back-to-menu-button">Back to Menu</button>
    </div>
  </div>

  <!-- External libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  
  <!-- Game logic script -->
  <script>
    // Add debug console logging
    console.log("Game script starting...");
    
    // Game state
    const gameState = {
      score: 0,
      combo: 0,
      maxCombo: 0,
      multiplier: 1.0,
      isPlaying: false,
      isPaused: false,
      energy: 0,
      specialMode: false,
      specialModeTime: 0,
      startTime: 0,
      elapsedTime: 0,
      songDuration: 120, // in seconds
      currentTrack: "synthwave",
      difficulty: "easy",
      stats: {
        perfect: 0,
        great: 0,
        good: 0,
        miss: 0
      },
      // Track specific settings
      trackSettings: {
        synthwave: {
          bpm: 100,
          title: "Synthwave Nights",
          color1: 0x6200ea,
          color2: 0xff3e80,
          skyColor: 0x120030,
          fogColor: 0x3a0070
        },
        electronic: {
          bpm: 110,
          title: "Electronic Pulse",
          color1: 0x00ccff,
          color2: 0x00ff88,
          skyColor: 0x001530,
          fogColor: 0x002050
        },
        dubstep: {
          bpm: 120,
          title: "Dubstep Dimension",
          color1: 0xff9500,
          color2: 0xff3333,
          skyColor: 0x300000,
          fogColor: 0x500000
        }
      },
      // Difficulty settings
      difficultySettings: {
        easy: {
          noteSpeed: 0.05,
          noteDensity: 0.08,
          laneCount: 4,
          label: "Easy",
          specialModeDuration: 30
        },
        medium: {
          noteSpeed: 0.15,
          noteDensity: 0.3,
          laneCount: 4,
          label: "Medium",
          specialModeDuration: 20
        },
        hard: {
          noteSpeed: 0.25,
          noteDensity: 0.5,
          laneCount: 4,
          label: "Hard",
          specialModeDuration: 10
        }
      }
    };
    
    // Keybindings
    let keys = {
      d: 0,
      f: 1,
      j: 2,
      k: 3
    };
    
    // Lane indicators
    const laneIndicators = [];
    
    // Colors for lanes based on current track
    let laneColors = [];
    
    // Three.js variables
    let scene, camera, renderer;
    let targetZone, targetZoneLine;
    let lanes = [];
    let notes = [];
    let notesToRemove = [];
    let noteGenerators = [];
    let skybox;
    let particleSystem;
    let particles = [];
    let ground, groundMaterial;
    let laneObjects = [];
    
    // Audio variables
    let synth, basslineSynth, padSynth, kickSampler, snareSampler, hihatSampler;
    let masterCompressor, reverbEffect, delayEffect;
    let melodicPatterns = [];
    let basslinePatterns = [];
    let kickPatterns = [];
    let snarePatterns = [];
    let hihatPatterns = [];
    let currentTheme;
    
    // Patterns for different tracks
    const trackPatterns = {
      synthwave: {
        melodic: [
          ["C4", "E4", "G4", "B4"],
          ["A3", "C4", "E4", "G4"],
          ["F3", "A3", "C4", "E4"],
          ["G3", "B3", "D4", "F4"]
        ],
        bass: [
          ["C2", "C2", "G2", "C2"],
          ["A1", "A1", "E2", "A1"],
          ["F1", "F1", "C2", "F1"],
          ["G1", "G1", "D2", "G1"]
        ]
      },
      electronic: {
        melodic: [
          ["D4", "F#4", "A4", "C5"],
          ["B3", "D4", "F#4", "A4"],
          ["G3", "B3", "D4", "F#4"],
          ["A3", "C#4", "E4", "G4"]
        ],
        bass: [
          ["D2", "D2", "A2", "D2"],
          ["B1", "B1", "F#2", "B1"],
          ["G1", "G1", "D2", "G1"],
          ["A1", "A1", "E2", "A1"]
        ]
      },
      dubstep: {
        melodic: [
          ["F3", "G#3", "C4", "D#4"],
          ["D#3", "G3", "A#3", "D4"],
          ["G#2", "C3", "D#3", "G3"],
          ["C3", "D#3", "G3", "A#3"]
        ],
        bass: [
          ["F1", "F1", "F1", "F1"],
          ["D#1", "D#1", "D#1", "D#1"],
          ["G#0", "G#0", "G#0", "G#0"],
          ["C1", "C1", "C1", "C1"]
        ]
      }
    };
    
    // Debug counter to track note creation
    let debugNoteCount = 0;
    
    // Initialize the game when the page loads
    window.addEventListener('load', () => {
      console.log("Window loaded, initializing game...");
      try {
        initScene();
        initAudio();
        setupEventListeners();
        // Start the animation loop
        animate();
      } catch (error) {
        console.error("Error during initialization:", error);
        alert("Error initializing game: " + error.message);
      }
    });
    
    // Initialize Three.js scene
    function initScene() {
      console.log("Initializing 3D scene...");
      try {
        // Create scene
        scene = new THREE.Scene();
        
        // Add fog for depth
        scene.fog = new THREE.Fog(gameState.trackSettings[gameState.currentTrack].fogColor, 5, 50);
        
        // Set background color
        scene.background = new THREE.Color(gameState.trackSettings[gameState.currentTrack].skyColor);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4, 10);
        camera.lookAt(0, 0, -15);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        // Update lane colors based on current track
        updateLaneColors();
        
        // Create skybox
        createSkybox();
        
        // Add lighting
        createLighting();
        
        // Create ground
        createGround();
        
        // Create target zone
        createTargetZone();
        
        // Create lanes
        createLanes();
        
        // Create note generators
        createNoteGenerators();
        
        // Create lane indicators
        createLaneIndicators();
        
        // Add window resize listener
        window.addEventListener('resize', onWindowResize);
        
        console.log("Scene initialized successfully");
      } catch (error) {
        console.error("Error in initScene:", error);
        throw new Error("Failed to initialize 3D scene: " + error.message);
      }
    }
    
    // Update lane colors based on current track
    function updateLaneColors() {
      const trackSetting = gameState.trackSettings[gameState.currentTrack];
      laneColors = [
        trackSetting.color1,
        trackSetting.color2,
        trackSetting.color1,
        trackSetting.color2
      ];
    }
    
    // Create a stylized skybox
    function createSkybox() {
      const geometry = new THREE.BoxGeometry(500, 500, 500);
      const trackSetting = gameState.trackSettings[gameState.currentTrack];
      
      // Create materials for each face with gradients
      const materials = [];
      
      // Top - gradient
      const topCanvas = document.createElement('canvas');
      topCanvas.width = 512;
      topCanvas.height = 512;
      const topCtx = topCanvas.getContext('2d');
      const topGradient = topCtx.createLinearGradient(0, 0, 0, 512);
      topGradient.addColorStop(0, '#000000');
      topGradient.addColorStop(1, '#' + new THREE.Color(trackSetting.skyColor).getHexString());
      topCtx.fillStyle = topGradient;
      topCtx.fillRect(0, 0, 512, 512);
      
      // Add stars to top
      topCtx.fillStyle = 'white';
      for (let i = 0; i < 200; i++) {
        const size = Math.random() * 2;
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        topCtx.globalAlpha = Math.random() * 0.8 + 0.2;
        topCtx.beginPath();
        topCtx.arc(x, y, size, 0, Math.PI * 2);
        topCtx.fill();
      }
      
      const topTexture = new THREE.CanvasTexture(topCanvas);
      
      // Bottom - solid color
      const bottomMaterial = new THREE.MeshBasicMaterial({
        color: new THREE.Color(trackSetting.skyColor),
        side: THREE.BackSide
      });
      
      // Side materials with grid effect
      const sideCanvas = document.createElement('canvas');
      sideCanvas.width = 512;
      sideCanvas.height = 512;
      const sideCtx = sideCanvas.getContext('2d');
      
      // Background gradient
      const sideGradient = sideCtx.createLinearGradient(0, 0, 0, 512);
      sideGradient.addColorStop(0, '#' + new THREE.Color(trackSetting.skyColor).getHexString());
      sideGradient.addColorStop(1, '#000000');
      sideCtx.fillStyle = sideGradient;
      sideCtx.fillRect(0, 0, 512, 512);
      
      // Grid lines
      sideCtx.strokeStyle = '#' + new THREE.Color(trackSetting.color1).getHexString();
      sideCtx.lineWidth = 1;
      sideCtx.globalAlpha = 0.3;
      
      // Horizontal lines
      for (let i = 0; i < 20; i++) {
        const y = i * 25;
        sideCtx.beginPath();
        sideCtx.moveTo(0, y);
        sideCtx.lineTo(512, y);
        sideCtx.stroke();
      }
      
      // Vertical lines
      for (let i = 0; i < 20; i++) {
        const x = i * 25;
        sideCtx.beginPath();
        sideCtx.moveTo(x, 0);
        sideCtx.lineTo(x, 512);
        sideCtx.stroke();
      }
      
      const sideTexture = new THREE.CanvasTexture(sideCanvas);
      
      // Create materials array for skybox
      materials.push(
        new THREE.MeshBasicMaterial({ map: sideTexture, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ map: sideTexture, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ map: topTexture, side: THREE.BackSide }),
        bottomMaterial,
        new THREE.MeshBasicMaterial({ map: sideTexture, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ map: sideTexture, side: THREE.BackSide })
      );
      
      // Create skybox mesh
      skybox = new THREE.Mesh(geometry, materials);
      scene.add(skybox);
    }
    
    // Create lighting setup
    function createLighting() {
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);
      
      // Add directional light for general illumination
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 15, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 50;
      directionalLight.shadow.camera.left = -20;
      directionalLight.shadow.camera.right = 20;
      directionalLight.shadow.camera.top = 20;
      directionalLight.shadow.camera.bottom = -20;
      scene.add(directionalLight);
      
      // Add point lights for lane highlighting
      const laneCount = gameState.difficultySettings[gameState.difficulty].laneCount;
      
      for (let i = 0; i < laneCount; i++) {
        const pointLight = new THREE.PointLight(laneColors[i], 0.5, 10);
        pointLight.position.set(
          (i - (laneCount - 1) / 2) * 1.2,
          2,
          0
        );
        scene.add(pointLight);
      }
      
      // Add spotlight for target zone
      const spotlight = new THREE.SpotLight(0xffffff, 1, 30, Math.PI / 6, 0.5, 1);
      spotlight.position.set(0, 8, 5);
      spotlight.target.position.set(0, 0, 0);
      spotlight.castShadow = true;
      spotlight.shadow.mapSize.width = 1024;
      spotlight.shadow.mapSize.height = 1024;
      scene.add(spotlight);
      scene.add(spotlight.target);
    }
    
    // Create ground with grid material
    function createGround() {
      const trackSetting = gameState.trackSettings[gameState.currentTrack];
      
      // Create grid texture
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // Black background
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, 512, 512);
      
      // Grid lines
      ctx.strokeStyle = '#' + new THREE.Color(trackSetting.color1).getHexString();
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.3;
      
      // Horizontal lines
      for (let i = 0; i < 20; i++) {
        const y = i * 25;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(512, y);
        ctx.stroke();
      }
      
      // Vertical lines
      for (let i = 0; i < 20; i++) {
        const x = i * 25;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 512);
        ctx.stroke();
      }
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(10, 20);
      
      // Create ground material with glow effect
      groundMaterial = new THREE.MeshStandardMaterial({
        map: texture,
        color: 0x000000,
        emissive: trackSetting.color1,
        emissiveIntensity: 0.1,
        metalness: 0.8,
        roughness: 0.2
      });
      
      // Create ground mesh
      const geometry = new THREE.PlaneGeometry(50, 100);
      ground = new THREE.Mesh(geometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -0.5;
      ground.position.z = -25;
      ground.receiveShadow = true;
      scene.add(ground);
    }
    
    // Create target zone with effects
    function createTargetZone() {
      const laneCount = gameState.difficultySettings[gameState.difficulty].laneCount;
      
      targetZone = new THREE.Group();
      
      // Create target zone platform
      const platformGeometry = new THREE.BoxGeometry(laneCount * 1.5, 0.2, 3);
      const platformMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000,
        metalness: 0.9,
        roughness: 0.2,
        emissive: 0xffffff,
        emissiveIntensity: 0.05
      });
      
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.4;
      platform.receiveShadow = true;
      targetZone.add(platform);
      
      // Create target zone line
      const lineGeometry = new THREE.BoxGeometry(laneCount * 1.5, 0.1, 0.1);
      const lineMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.8,
        transparent: true,
        opacity: 0.8
      });
      
      targetZoneLine = new THREE.Mesh(lineGeometry, lineMaterial);
      targetZoneLine.position.y = 0.1;
      targetZone.add(targetZoneLine);
      
      // Add glowing ring at target zone
      const ringGeometry = new THREE.RingGeometry(laneCount * 0.7, laneCount * 0.8, 32);
      const ringMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = -Math.PI / 2;
      ring.position.y = -0.3;
      targetZone.add(ring);
      
      // Create particle system for effects
      createParticleSystem();
      
      // Position the target zone
      targetZone.position.z = 0;
      scene.add(targetZone);
    }
    
    // Create particle system for visual effects
    function createParticleSystem() {
      // We'll manage particles manually with HTML elements
      particleSystem = document.createElement('div');
      particleSystem.style.position = 'absolute';
      particleSystem.style.top = '0';
      particleSystem.style.left = '0';
      particleSystem.style.width = '100%';
      particleSystem.style.height = '100%';
      particleSystem.style.pointerEvents = 'none';
      particleSystem.style.overflow = 'hidden';
      document.getElementById('game-container').appendChild(particleSystem);
    }
    
    // Create lanes for notes to travel on
    function createLanes() {
      const laneCount = gameState.difficultySettings[gameState.difficulty].laneCount;
      const laneWidth = 1;
      const laneLength = 60;
      
      for (let i = 0; i < laneCount; i++) {
        // Create lane floor
        const laneGeometry = new THREE.PlaneGeometry(laneWidth, laneLength);
        const laneMaterial = new THREE.MeshStandardMaterial({ 
          color: laneColors[i],
          transparent: true,
          opacity: 0.2,
          metalness: 0.8,
          roughness: 0.2,
          emissive: laneColors[i],
          emissiveIntensity: 0.1
        });
        
        const lane = new THREE.Mesh(laneGeometry, laneMaterial);
        lane.rotation.x = -Math.PI / 2;
        lane.position.x = (i - (laneCount - 1) / 2) * 1.2;
        lane.position.y = -0.35;
        lane.position.z = -laneLength / 2 + 1.5;
        scene.add(lane);
        lanes.push(lane);
        
        // Create lane side walls
        const wallGeometry = new THREE.BoxGeometry(0.05, 0.5, laneLength);
        const wallMaterial = new THREE.MeshStandardMaterial({
          color: laneColors[i],
          transparent: true,
          opacity: 0.3,
          emissive: laneColors[i],
          emissiveIntensity: 0.2
        });
        
        // Left wall
        const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
        leftWall.position.x = (i - (laneCount - 1) / 2) * 1.2 - laneWidth / 2;
        leftWall.position.y = -0.1;
        leftWall.position.z = -laneLength / 2 + 1.5;
        scene.add(leftWall);
        
        // Right wall
        const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
        rightWall.position.x = (i - (laneCount - 1) / 2) * 1.2 + laneWidth / 2;
        rightWall.position.y = -0.1;
        rightWall.position.z = -laneLength / 2 + 1.5;
        scene.add(rightWall);
        
        // Store all lane related objects
        laneObjects.push({
          floor: lane,
          leftWall: leftWall,
          rightWall: rightWall
        });
      }
    }
    
    // Create note generators at the end of lanes
    function createNoteGenerators() {
      const laneCount = gameState.difficultySettings[gameState.difficulty].laneCount;
      
      for (let i = 0; i < laneCount; i++) {
        // Create generator light
        const generatorGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const generatorMaterial = new THREE.MeshStandardMaterial({
          color: laneColors[i],
          emissive: laneColors[i],
          emissiveIntensity: 0.8,
          transparent: true,
          opacity: 0.7
        });
        
        const generator = new THREE.Mesh(generatorGeometry, generatorMaterial);
        generator.position.set(
          (i - (laneCount - 1) / 2) * 1.2,
          0,
          -30
        );
        scene.add(generator);
        noteGenerators.push(generator);
      }
    }
    
    // Create lane indicators at the bottom of the screen
    function createLaneIndicators() {
      const laneCount = gameState.difficultySettings[gameState.difficulty].laneCount;
      const keyNames = Object.keys(keys);
      
      for (let i = 0; i < laneCount; i++) {
        const indicator = document.createElement('div');
        indicator.classList.add('lane-indicator');
        indicator.style.left = `${(i + 1) * (100 / (laneCount + 1))}%`;
        indicator.style.backgroundColor = '#' + new THREE.Color(laneColors[i]).getHexString();
        indicator.innerHTML = keyNames[i].toUpperCase();
        
        document.getElementById('game-container').appendChild(indicator);
        laneIndicators.push(indicator);
      }
    }
    
    // Initialize Tone.js audio system
    function initAudio() {
      console.log("Initializing audio system...");
      try {
        // Master effects chain
        masterCompressor = new Tone.Compressor({
          threshold: -15,
          ratio: 7,
          attack: 0.003,
          release: 0.25
        }).toDestination();
        
        reverbEffect = new Tone.Reverb({
          decay: 2.5,
          wet: 0.2
        }).connect(masterCompressor);
        
        delayEffect = new Tone.PingPongDelay({
          delayTime: "8n",
          feedback: 0.2,
          wet: 0.1
        }).connect(reverbEffect);
        
        // Create synth for note hit feedback
        synth = new Tone.Synth({
          oscillator: {
            type: "triangle8"
          },
          envelope: {
            attack: 0.005,
            decay: 0.1,
            sustain: 0.3,
            release: 0.4
          }
        }).connect(delayEffect);
        
        // Create bassline synth
        basslineSynth = new Tone.MonoSynth({
          oscillator: {
            type: "square"
          },
          envelope: {
            attack: 0.05,
            decay: 0.2,
            sustain: 0.5,
            release: 0.1
          },
          filter: {
            Q: 2,
            type: "lowpass",
            rolloff: -24
          },
          filterEnvelope: {
            attack: 0.05,
            decay: 0.5,
            sustain: 0.7,
            release: 0.2,
            baseFrequency: 200,
            octaves: 2.5
          }
        }).connect(masterCompressor);
        basslineSynth.volume.value = -8;
        
        // Create pad synth for ambient chords
        padSynth = new Tone.PolySynth(Tone.Synth, {
          oscillator: {
            type: "sine"
          },
          envelope: {
            attack: 0.8,
            decay: 0.2,
            sustain: 0.9,
            release: 2
          }
        }).connect(reverbEffect);
        padSynth.volume.value = -15;
        
        // Create simple samplers with oscillators instead of loading external files
        kickSampler = new Tone.MembraneSynth({
          pitchDecay: 0.05,
          octaves: 10,
          oscillator: {
            type: "sine"
          },
          envelope: {
            attack: 0.001,
            decay: 0.4,
            sustain: 0.01,
            release: 1.4,
            attackCurve: "exponential"
          }
        }).connect(masterCompressor);
        kickSampler.volume.value = -6;
        
        snareSampler = new Tone.NoiseSynth({
          noise: {
            type: "white"
          },
          envelope: {
            attack: 0.001,
            decay: 0.2,
            sustain: 0,
            release: 0.2
          }
        }).connect(delayEffect);
        snareSampler.volume.value = -8;
        
        hihatSampler = new Tone.MetalSynth({
          frequency: 200,
          envelope: {
            attack: 0.001,
            decay: 0.1,
            release: 0.01
          },
          harmonicity: 5.1,
          modulationIndex: 32,
          resonance: 4000,
          octaves: 1.5
        }).connect(reverbEffect);
        hihatSampler.volume.value = -12;
        
        // Load music patterns based on current track
        loadMusicPatterns();
        
        // Set up various musical loops
        setupMusicLoops();
        
        // Set BPM
        Tone.Transport.bpm.value = gameState.trackSettings[gameState.currentTrack].bpm;
        
        console.log("Audio system initialized successfully");
      } catch (error) {
        console.error("Error in initAudio:", error);
        throw new Error("Failed to initialize audio system: " + error.message);
      }
    }
    
    // Load music patterns based on current track
    function loadMusicPatterns() {
      // Get patterns for current track
      const currentPattern = trackPatterns[gameState.currentTrack];
      
      // Set melodic patterns
      melodicPatterns = currentPattern.melodic;
      
      // Set bassline patterns
      basslinePatterns = currentPattern.bass;
      
      // Set drum patterns based on track and difficulty
      const diffSetting = gameState.difficultySettings[gameState.difficulty];
      
      // Kick patterns
      if (gameState.currentTrack === "dubstep") {
        kickPatterns = [
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 0, 0, 0, 1, 0, 1, 0],
          [1, 0, 1, 0, 1, 0, 0, 0],
          [1, 0, 0, 1, 1, 0, 0, 1]
        ];
      } else {
        kickPatterns = [
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 0, 0, 0, 1, 0, 0, 0],
          [1, 1, 0, 0, 1, 0, 0, 0]
        ];
      }
      
      // Snare patterns
      snarePatterns = [
        [0, 0, 1, 0, 0, 0, 1, 0],
        [0, 0, 1, 0, 0, 0, 1, 0],
        [0, 0, 1, 0, 0, 0, 1, 0],
        [0, 0, 1, 0, 0, 0, 1, 1]
      ];
      
      // Hi-hat patterns
      if (gameState.difficulty === "easy") {
        hihatPatterns = [
          [1, 0, 1, 0, 1, 0, 1, 0],
          [1, 0, 1, 0, 1, 0, 1, 0],
          [1, 0, 1, 0, 1, 0, 1, 0],
          [1, 0, 1, 0, 1, 0, 1, 0]
        ];
      } else if (gameState.difficulty === "medium") {
        hihatPatterns = [
          [1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 1, 1, 1, 0, 1, 1],
          [1, 1, 1, 0, 1, 1, 1, 0],
          [1, 1, 1, 1, 1, 1, 1, 1]
        ];
      } else {
        hihatPatterns = [
          [1, 1, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
          [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1]
        ];
      }
    }
    
    // Set up all music loops
    function setupMusicLoops() {
      // Reset existing loops if needed
      Tone.Transport.cancel();
      
      // Set up melodic loop (plays every 2 bars)
      Tone.Transport.scheduleRepeat((time) => {
        if (!gameState.isPlaying || gameState.isPaused) return;
        
        // Determine which pattern to play based on current bar
        const currentBar = Math.floor(Tone.Transport.position.split(':')[0]) % 8;
        const patternIndex = Math.floor(currentBar / 2) % melodicPatterns.length;
        
        // Get the current pattern
        const currentPattern = melodicPatterns[patternIndex];
        
        // Play chord
        if (currentBar % 2 === 0) {
          padSynth.triggerAttackRelease(currentPattern, "2n", time);
        }
        
      }, "2m");
      
      // Set up bassline loop (plays every beat)
      Tone.Transport.scheduleRepeat((time) => {
        if (!gameState.isPlaying || gameState.isPaused) return;
        
        // Determine current position
        const position = Tone.Transport.position;
        const [bars, quarters] = position.split(':').map(v => parseInt(v));
        
        // Determine which pattern to play
        const patternIndex = Math.floor(bars / 2) % basslinePatterns.length;
        const noteIndex = quarters % 4;
        
        // Get the current note
        const currentNote = basslinePatterns[patternIndex][noteIndex];
        
        // Play note with slight probability variations for dynamics
        if (Math.random() > 0.1) {
          basslineSynth.triggerAttackRelease(currentNote, "8n", time);
        }
        
      }, "4n");
      
      // Set up drum loops
      
      // Kick drum loop
      Tone.Transport.scheduleRepeat((time) => {
        if (!gameState.isPlaying || gameState.isPaused) return;
        
        // Determine current position
        const position = Tone.Transport.position;
        const [bars, quarters, sixteenths] = position.split(':').map(v => parseInt(v));
        
        // Determine which pattern to play
        const patternIndex = bars % kickPatterns.length;
        const stepIndex = (quarters * 2 + Math.floor(sixteenths / 4)) % 8;
        
        // Check if there's a kick at this step
        if (kickPatterns[patternIndex][stepIndex]) {
          kickSampler.triggerAttackRelease("C2", "32n", time);
          
          // Generate note with small probability if special mode is active
          if (gameState.specialMode && Math.random() < 0.3) {
            const laneIndex = Math.floor(Math.random() * gameState.difficultySettings[gameState.difficulty].laneCount);
            createNote(laneIndex, true);
          }
        }
        
      }, "8n");
      
      // Snare drum loop
      Tone.Transport.scheduleRepeat((time) => {
        if (!gameState.isPlaying || gameState.isPaused) return;
        
        // Determine current position
        const position = Tone.Transport.position;
        const [bars, quarters, sixteenths] = position.split(':').map(v => parseInt(v));
        
        // Determine which pattern to play
        const patternIndex = bars % snarePatterns.length;
        const stepIndex = (quarters * 2 + Math.floor(sixteenths / 4)) % 8;
        
        // Check if there's a snare at this step
        if (snarePatterns[patternIndex][stepIndex]) {
          snareSampler.triggerAttackRelease("D2", "32n", time);
          
          // Generate note with moderate probability based on difficulty
          if (!gameState.specialMode) {
            const diffSetting = gameState.difficultySettings[gameState.difficulty];
            if (Math.random() < diffSetting.noteDensity) {
              const laneIndex = Math.floor(Math.random() * diffSetting.laneCount);
              createNote(laneIndex);
            }
          }
        }
        
      }, "8n");
      
      // Hi-hat loop
      Tone.Transport.scheduleRepeat((time) => {
        if (!gameState.isPlaying || gameState.isPaused) return;
        
        // Determine current position
        const position = Tone.Transport.position;
        const [bars, quarters, sixteenths] = position.split(':').map(v => parseInt(v));
        
        // Determine which pattern to play
        const patternIndex = bars % hihatPatterns.length;
        const patternLength = hihatPatterns[patternIndex].length;
        const stepIndex = (quarters * 4 + sixteenths) % patternLength;
        
        // Check if there's a hi-hat at this step
        if (hihatPatterns[patternIndex][stepIndex]) {
          // Alternate between open and closed hi-hat
          const note = stepIndex % 2 === 0 ? "F#2" : "G#2";
          hihatSampler.triggerAttackRelease(note, "64n", time);
          
          // Generate note with small probability for harder difficulties
          if (!gameState.specialMode && gameState.difficulty !== "easy") {
            const diffSetting = gameState.difficultySettings[gameState.difficulty];
            if (Math.random() < diffSetting.noteDensity * 0.5) {
              const laneIndex = Math.floor(Math.random() * diffSetting.laneCount);
              createNote(laneIndex);
            }
          }
        }
        
      }, "16n");
    }
    
    // Add particle effect
    function addParticleEffect(x, y, color, count = 20) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.width = Math.random() * 10 + 5 + 'px';
        particle.style.height = particle.style.width;
        particle.style.backgroundColor = color;
        
        // Convert 3D position to screen coordinates
        const vector = new THREE.Vector3(x, y, 0);
        vector.project(camera);
        
        const screenX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const screenY = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
        
        particle.style.left = screenX + 'px';
        particle.style.top = screenY + 'px';
        
        // Random velocity
        const vx = (Math.random() - 0.5) * 20;
        const vy = (Math.random() - 0.5) * 20 - 10;
        
        // Add to DOM
        particleSystem.appendChild(particle);
        
        // Store particle data
        particles.push({
          element: particle,
          x: screenX,
          y: screenY,
          vx: vx,
          vy: vy,
          opacity: 1,
          size: parseFloat(particle.style.width),
          creationTime: Date.now()
        });
      }
    }
    
    // Update all particles
    function updateParticles() {
      const now = Date.now();
      const particlesToRemove = [];
      
      for (let i = 0; i < particles.length; i++) {
        const particle = particles[i];
        
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vy += 0.5; // Gravity
        particle.opacity -= 0.02;
        particle.size *= 0.98;
        
        // Update DOM element
        particle.element.style.left = particle.x + 'px';
        particle.element.style.top = particle.y + 'px';
        particle.element.style.opacity = particle.opacity;
        particle.element.style.width = particle.size + 'px';
        particle.element.style.height = particle.size + 'px';
        
        // Check if particle should be removed
        if (particle.opacity <= 0 || now - particle.creationTime > 2000) {
          particlesToRemove.push(i);
        }
      }
      
      // Remove dead particles (in reverse order to avoid index issues)
      for (let i = particlesToRemove.length - 1; i >= 0; i--) {
        const index = particlesToRemove[i];
        particleSystem.removeChild(particles[index].element);
        particles.splice(index, 1);
      }
    }
    
    // Show combo popup animation
    function showComboPopup(combo) {
      if (combo % 10 !== 0 || combo === 0) return;
      
      const popup = document.createElement('div');
      popup.className = 'combo-popup';
      popup.textContent = combo + ' COMBO!';
      
      // Random position near the center
      const x = Math.random() * 200 - 100;
      const y = Math.random() * 100 - 50;
      
      popup.style.left = `calc(50% + ${x}px)`;
      popup.style.top = `calc(50% + ${y}px)`;
      
      document.getElementById('game-container').appendChild(popup);
      
      // Animate in
      setTimeout(() => {
        popup.style.opacity = '1';
        popup.style.transform = 'scale(1.2)';
      }, 10);
      
      // Animate out
      setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'scale(0.8) translateY(-50px)';
      }, 1000);
      
      // Remove from DOM
      setTimeout(() => {
        popup.remove();
      }, 1500);
    }
    
    // Handles key press for playing notes
    function handleKeyPress(event) {
      if (!gameState.isPlaying || gameState.isPaused) return;
      
      // Handle pause key
      if (event.key === 'Escape') {
        togglePause();
        return;
      }
      
      // Handle special mode activation
      if (event.key === ' ' && gameState.energy >= 100) {
        activateSpecialMode();
        return;
      }
      
      const key = event.key.toLowerCase();
      if (keys[key] !== undefined) {
        const laneIndex = keys[key];
        
        // Find closest note in this lane
        let closestNote = null;
        let closestDistance = Infinity;
        
        for (const note of notes) {
          if (note.userData.laneIndex === laneIndex && note.userData.active) {
            const distance = Math.abs(note.position.z);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestNote = note;
            }
          }
        }
        
        // Check if we hit a note
        if (closestNote && closestDistance < 2) {
          // Calculate score based on distance
          let hitResult = "";
          let scoreToAdd = 0;
          let hitColor = "";
          let energyToAdd = 0;
          
          if (closestDistance < 0.5) {
            hitResult = "PERFECT!";
            scoreToAdd = 100;
            energyToAdd = 5;
            gameState.combo++;
            gameState.stats.perfect++;
            
            // Visual feedback
            closestNote.scale.set(1.5, 1.5, 1.5);
            closestNote.material.emissiveIntensity = 1;
            
            // Sound feedback
            const octave = closestNote.userData.isSpecial ? 5 : 4;
            const notes = ["C", "D", "E", "F"];
            synth.triggerAttackRelease(notes[laneIndex] + octave, "16n");
            
            // Particle effect
            addParticleEffect(
              closestNote.position.x,
              closestNote.position.y,
              '#00ffaa',
              30
            );
          } else if (closestDistance < 1.0) {
            hitResult = "GREAT";
            scoreToAdd = 75;
            energyToAdd = 3;
            gameState.combo++;
            hitColor = "great";
            gameState.stats.great++;
            
            // Visual feedback
            closestNote.scale.set(1.3, 1.3, 1.3);
            closestNote.material.emissiveIntensity = 0.9;
            
            // Sound feedback
            const notes = ["C", "D", "E", "F"];
            synth.triggerAttackRelease(notes[laneIndex] + "3", "16n");
            
            // Particle effect
            addParticleEffect(
              closestNote.position.x,
              closestNote.position.y,
              '#00ccff',
              20
            );
          } else if (closestDistance < 1.5) {
            hitResult = "GOOD";
            scoreToAdd = 50;
            energyToAdd = 2;
            gameState.combo++;
            hitColor = "good";
            gameState.stats.good++;
            
            // Visual feedback
            closestNote.scale.set(1.2, 1.2, 1.2);
            closestNote.material.emissiveIntensity = 0.8;
            
            // Sound feedback
            const notes = ["A", "B", "G", "A"];
            synth.triggerAttackRelease(notes[laneIndex] + "3", "16n");
            
            // Particle effect
            addParticleEffect(
              closestNote.position.x,
              closestNote.position.y,
              '#ffcc00',
              15
            );
          } else {
            hitResult = "MISS";
            gameState.combo = 0;
            hitColor = "miss";
            gameState.stats.miss++;
            
            // Sound feedback
            const notes = ["C", "D", "E", "F"];
            synth.triggerAttackRelease(notes[laneIndex] + "2", "32n");
          }
          
          // Double points for special notes
          if (closestNote.userData.isSpecial) {
            scoreToAdd *= 2;
            energyToAdd *= 2;
            hitResult = "SPECIAL " + hitResult;
          }
          
          // Calculate multiplier based on combo
          gameState.multiplier = 1 + Math.floor(gameState.combo / 10) * 0.1;
          gameState.multiplier = Math.min(gameState.multiplier, 2.0);
          
          // Apply multiplier to score
          scoreToAdd = Math.floor(scoreToAdd * gameState.multiplier);
          
          // Add energy for special move
          gameState.energy = Math.min(gameState.energy + energyToAdd, 100);
          document.getElementById('energy-bar').style.width = gameState.energy + '%';
          
          // Update special ready indicator
          if (gameState.energy >= 100) {
            document.getElementById('special-ready').style.opacity = 1;
            document.getElementById('special-ready').style.animation = 'pulse 1s infinite';
          }
          
          // Update max combo
          if (gameState.combo > gameState.maxCombo) {
            gameState.maxCombo = gameState.combo;
          }
          
          // Update score
          gameState.score += scoreToAdd;
          
          // Update UI
          document.getElementById("score").textContent = `Score: ${gameState.score}`;
          document.getElementById("combo").textContent = `Combo: ${gameState.combo}`;
          document.getElementById("multiplier").textContent = `Multiplier: x${gameState.multiplier.toFixed(1)}`;
          
          // Show combo popup for milestones
          showComboPopup(gameState.combo);
          
          // Show hit feedback
          const hitFeedback = document.getElementById("hit-feedback");
          hitFeedback.textContent = hitResult;
          hitFeedback.className = hitColor;
          hitFeedback.style.opacity = 1;
          hitFeedback.style.transform = "translate(-50%, -50%) scale(1.2)";
          
          setTimeout(() => {
            hitFeedback.style.opacity = 0;
            hitFeedback.style.transform = "translate(-50%, -50%) scale(1)";
          }, 300);
          
          // Mark the note as inactive
          closestNote.userData.active = false;
          closestNote.userData.hit = true;
          notesToRemove.push(closestNote);
        } else {
          // Miss (no note nearby)
          gameState.combo = 0;
          gameState.multiplier = 1.0;
          gameState.stats.miss++;
          
          document.getElementById("combo").textContent = `Combo: ${gameState.combo}`;
          document.getElementById("multiplier").textContent = `Multiplier: x${gameState.multiplier.toFixed(1)}`;
          
          // Show miss feedback
          const hitFeedback = document.getElementById("hit-feedback");
          hitFeedback.textContent = "MISS";
          hitFeedback.className = "miss";
          hitFeedback.style.opacity = 1;
          hitFeedback.style.transform = "translate(-50%, -50%) scale(1.2)";
          
          setTimeout(() => {
            hitFeedback.style.opacity = 0;
            hitFeedback.style.transform = "translate(-50%, -50%) scale(1)";
          }, 300);
          
          // Sound feedback
          const notes = ["C", "D", "E", "F"];
          synth.triggerAttackRelease(notes[laneIndex] + "2", "32n");
        }
        
        // Visual feedback for lane
        if (laneObjects[laneIndex]) {
          laneObjects[laneIndex].floor.material.opacity = 0.6;
          laneObjects[laneIndex].leftWall.material.opacity = 0.8;
          laneObjects[laneIndex].rightWall.material.opacity = 0.8;
          
          setTimeout(() => {
            laneObjects[laneIndex].floor.material.opacity = 0.2;
            laneObjects[laneIndex].leftWall.material.opacity = 0.3;
            laneObjects[laneIndex].rightWall.material.opacity = 0.3;
          }, 100);
        }
        
        // Visual feedback for lane indicator
        if (laneIndicators[laneIndex]) {
          laneIndicators[laneIndex].style.transform = "translateX(-50%) translateY(-10px) scale(1.2)";
          
          setTimeout(() => {
            laneIndicators[laneIndex].style.transform = "translateX(-50%)";
          }, 100);
        }
      }
    }
    
    // Activate special mode
    function activateSpecialMode() {
      if (gameState.energy < 100 || gameState.specialMode) return;
      
      gameState.specialMode = true;
      gameState.specialModeTime = gameState.difficultySettings[gameState.difficulty].specialModeDuration;
      gameState.energy = 0;
      
      // Update UI
      document.getElementById('energy-bar').style.width = '0%';
      document.getElementById('special-ready').style.opacity = 0;
      document.getElementById('special-mode-overlay').style.opacity = 0.8;
      
      // Special sound effect
      const specialChord = ["C5", "E5", "G5", "B5"];
      padSynth.triggerAttackRelease(specialChord, "1n");
      
      // Visual effect - create a lot of particles
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = Math.cos(angle) * 3;
        const y = Math.sin(angle) * 1 + 1;
        
        // Get color from current track
        const trackSetting = gameState.trackSettings[gameState.currentTrack];
        const colorStr1 = '#' + new THREE.Color(trackSetting.color1).getHexString();
        const colorStr2 = '#' + new THREE.Color(trackSetting.color2).getHexString();
        
        addParticleEffect(x, y, i % 2 === 0 ? colorStr1 : colorStr2, 40);
      }
      
      // Change BPM temporarily
      const originalBpm = Tone.Transport.bpm.value;
      Tone.Transport.bpm.value *= 1.2;
      
      // Reset BPM after special mode ends
      setTimeout(() => {
        Tone.Transport.bpm.value = originalBpm;
        gameState.specialMode = false;
        document.getElementById('special-mode-overlay').style.opacity = 0;
      }, gameState.specialModeTime * 1000);
    }
    
    // Toggle pause state
    function togglePause() {
      gameState.isPaused = !gameState.isPaused;
      
      if (gameState.isPaused) {
        // Pause the music
        Tone.Transport.pause();
        
        // Show pause menu
        document.getElementById('pause-menu').style.opacity = 1;
        document.getElementById('pause-menu').style.pointerEvents = 'auto';
      } else {
        // Resume the music
        Tone.Transport.start();
        
        // Hide pause menu
        document.getElementById('pause-menu').style.opacity = 0;
        document.getElementById('pause-menu').style.pointerEvents = 'none';
      }
    }
    
    // Start the game
    function startGame() {
      console.log("Starting game...");
      try {
        // Hide start screen
        document.getElementById('start-screen').style.display = 'none';
        
        // Reset game state
        gameState.score = 0;
        gameState.combo = 0;
        gameState.maxCombo = 0;
        gameState.multiplier = 1.0;
        gameState.energy = 0;
        gameState.specialMode = false;
        gameState.startTime = Date.now();
        gameState.elapsedTime = 0;
        gameState.stats = {
          perfect: 0,
          great: 0,
          good: 0,
          miss: 0
        };
        
        // Clear any existing notes
        while (notes.length > 0) {
          const note = notes.pop();
          scene.remove(note);
        }
        
        // Update UI
        document.getElementById('score').textContent = `Score: ${gameState.score}`;
        document.getElementById('combo').textContent = `Combo: ${gameState.combo}`;
        document.getElementById('multiplier').textContent = `Multiplier: x${gameState.multiplier.toFixed(1)}`;
        document.getElementById('energy-bar').style.width = '0%';
        document.getElementById('special-ready').style.opacity = 0;
        
        // Update song info
        document.getElementById('song-title').textContent = gameState.trackSettings[gameState.currentTrack].title;
        document.getElementById('difficulty').textContent = gameState.difficultySettings[gameState.difficulty].label;
        document.getElementById('bpm').textContent = `BPM: ${gameState.trackSettings[gameState.currentTrack].bpm}`;
        
        // Show instructions briefly
        document.getElementById('instructions').style.opacity = 1;
        setTimeout(() => {
          document.getElementById('instructions').style.opacity = 0.3;
        }, 5000);
        
        // Set game as playing
        gameState.isPlaying = true;
        
        // Start the music transport
        Tone.Transport.start();
        
        // Set BPM based on current track
        Tone.Transport.bpm.value = gameState.trackSettings[gameState.currentTrack].bpm;
        
        // Generate initial notes
        generateInitialNotes();
        
        console.log("Game started successfully");
      } catch (error) {
        console.error("Error in startGame:", error);
        alert("Error starting game: " + error.message);
      }
    }
    
    // Set up event listeners for UI elements
    function setupEventListeners() {
      console.log("Setting up event listeners...");
      try {
        // Start button
        document.getElementById('start-button').addEventListener('click', startGame);
        
        // Track options
        const trackOptions = document.querySelectorAll('#track-options .option');
        trackOptions.forEach(option => {
          option.addEventListener('click', () => {
            // Remove selected class from all options
            trackOptions.forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            option.classList.add('selected');
            // Update game state
            gameState.currentTrack = option.dataset.track;
            // Update visuals based on new track
            updateTrackVisuals();
          });
        });
        
        // Difficulty options
        const difficultyOptions = document.querySelectorAll('#difficulty-options .option');
        difficultyOptions.forEach(option => {
          option.addEventListener('click', () => {
            // Remove selected class from all options
            difficultyOptions.forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            option.classList.add('selected');
            // Update game state
            gameState.difficulty = option.dataset.difficulty;
          });
        });
        
        // Pause menu buttons
        document.getElementById('resume-button').addEventListener('click', togglePause);
        document.getElementById('restart-button').addEventListener('click', () => {
          // Hide pause menu
          document.getElementById('pause-menu').style.opacity = 0;
          document.getElementById('pause-menu').style.pointerEvents = 'none';
          gameState.isPaused = false;
          
          // Reset and restart game
          startGame();
        });
        document.getElementById('quit-button').addEventListener('click', () => {
          // Hide pause menu
          document.getElementById('pause-menu').style.opacity = 0;
          document.getElementById('pause-menu').style.pointerEvents = 'none';
          gameState.isPaused = false;
          
          // Stop game and show start screen
          gameState.isPlaying = false;
          Tone.Transport.stop();
          document.getElementById('start-screen').style.display = 'flex';
        });
        
        // Results screen buttons
        document.getElementById('play-again-button').addEventListener('click', () => {
          // Hide results screen
          document.getElementById('results-screen').style.opacity = 0;
          document.getElementById('results-screen').style.pointerEvents = 'none';
          
          // Reset and restart game
          startGame();
        });
        document.getElementById('back-to-menu-button').addEventListener('click', () => {
          // Hide results screen
          document.getElementById('results-screen').style.opacity = 0;
          document.getElementById('results-screen').style.pointerEvents = 'none';
          
          // Show start screen
          document.getElementById('start-screen').style.display = 'flex';
        });
        
        // Add keyboard event listener for gameplay
        document.addEventListener('keydown', handleKeyPress);
        
        console.log("Event listeners set up successfully");
      } catch (error) {
        console.error("Error in setupEventListeners:", error);
        throw new Error("Failed to set up event listeners: " + error.message);
      }
    }
    
    // Function to update visuals when track changes
    function updateTrackVisuals() {
      // Update lane colors
      updateLaneColors();
      
      // Update skybox colors
      updateSkyboxColors();
      
      // Update ground colors
      updateGroundColors();
      
      // Load music patterns based on current track
      loadMusicPatterns();
      
      // Update track info in UI
      if (gameState.isPlaying) {
        document.getElementById('song-title').textContent = gameState.trackSettings[gameState.currentTrack].title;
        document.getElementById('bpm').textContent = `BPM: ${gameState.trackSettings[gameState.currentTrack].bpm}`;
      }
    }
    
    // Update skybox colors based on current track
    function updateSkyboxColors() {
      if (skybox) {
        scene.remove(skybox);
        createSkybox();
      }
    }
    
    // Update ground colors based on current track
    function updateGroundColors() {
      if (ground) {
        const trackSetting = gameState.trackSettings[gameState.currentTrack];
        groundMaterial.emissive.set(new THREE.Color(trackSetting.color1));
        scene.fog.color.set(new THREE.Color(trackSetting.fogColor));
        scene.background.set(new THREE.Color(trackSetting.skyColor));
      }
    }
    
    // Create a new note with effects
    function createNote(laneIndex, isSpecial = false) {
      // Debug note creation
      debugNoteCount++;
      console.log(`Creating note #${debugNoteCount} for lane ${laneIndex}`);
      
      // Base geometry
      const noteGeometry = new THREE.BoxGeometry(0.8, 0.3, 0.8);
      
      // Material based on special status
      let noteMaterial;
      
      if (isSpecial) {
        // Special note with more complex appearance
        noteMaterial = new THREE.MeshStandardMaterial({
          color: 0xffffff,
          emissive: 0xffffff,
          emissiveIntensity: 0.8,
          metalness: 1.0,
          roughness: 0.1
        });
      } else {
        // Regular note
        noteMaterial = new THREE.MeshStandardMaterial({
          color: laneColors[laneIndex],
          emissive: laneColors[laneIndex],
          emissiveIntensity: 0.5,
          metalness: 0.7,
          roughness: 0.3
        });
      }
      
      // Create note mesh
      const note = new THREE.Mesh(noteGeometry, noteMaterial);
      note.position.set(
        (laneIndex - (gameState.difficultySettings[gameState.difficulty].laneCount - 1) / 2) * 1.2,
        0,
        -30 // Start far away
      );
      note.castShadow = true;
      
      // Add metadata to note
      note.userData = {
        laneIndex: laneIndex,
        active: true,
        isSpecial: isSpecial,
        creationTime: gameState.elapsedTime
      };
      
      // Add to scene and notes array
      scene.add(note);
      notes.push(note);
      
      return note;
    }
    
    // Add function to generate initial notes at game start
    function generateInitialNotes() {
      if (!gameState.isPlaying) return;
      
      console.log("Generating initial notes");
      const diffSetting = gameState.difficultySettings[gameState.difficulty];
      const laneCount = diffSetting.laneCount;
      
      // Create some initial notes spread out so player doesn't wait
      for (let i = 0; i < 8; i++) {
        const laneIndex = Math.floor(Math.random() * laneCount);
        const note = createNote(laneIndex);
        // Position notes at different distances
        note.position.z = -30 + i * 3;
      }
      
      console.log("Created initial notes:", notes.length);
    }
    
    // FIX: Add the missing onWindowResize function
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Update the game loop to handle game ending
    function animate() {
      try {
        requestAnimationFrame(animate);
        
        if (gameState.isPlaying) {
          // Update elapsed time
          gameState.elapsedTime = (Date.now() - gameState.startTime) / 1000;
          
          // Update timer display
          const minutes = Math.floor(gameState.elapsedTime / 60);
          const seconds = Math.floor(gameState.elapsedTime % 60);
          document.getElementById('timer').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          // Update progress bar
          const progress = Math.min(gameState.elapsedTime / gameState.songDuration, 1);
          document.getElementById('progress-bar').style.width = (progress * 100) + '%';
          
          // Check if game should end
          if (gameState.elapsedTime >= gameState.songDuration) {
            endGame();
          }
          
          // Only update game elements if not paused
          if (!gameState.isPaused) {
            updateNotes();
            updateParticles();
            
            // Special mode timer
            if (gameState.specialMode) {
              gameState.specialModeTime -= 1/60; // Assuming 60fps
              if (gameState.specialModeTime <= 0) {
                gameState.specialMode = false;
                document.getElementById('special-mode-overlay').style.opacity = 0;
              }
            }
          }
        }
        
        // Render the scene
        renderer.render(scene, camera);
        
        // Pulse effect for target zone
        if (targetZoneLine) {
          targetZoneLine.scale.x = 1 + Math.sin(gameState.elapsedTime * 5) * 0.1;
        }
      } catch (error) {
        console.error("Error in animation loop:", error);
        // Don't stop the loop on error, just log it
      }
    }
    
    // End game and show results
    function endGame() {
      gameState.isPlaying = false;
      Tone.Transport.stop();
      
      // Update results screen
      document.getElementById('result-score').textContent = gameState.score;
      document.getElementById('result-max-combo').textContent = gameState.maxCombo;
      document.getElementById('result-perfect').textContent = gameState.stats.perfect;
      document.getElementById('result-great').textContent = gameState.stats.great;
      document.getElementById('result-good').textContent = gameState.stats.good;
      document.getElementById('result-miss').textContent = gameState.stats.miss;
      
      // Calculate rating
      let rating = "F";
      const totalNotes = gameState.stats.perfect + gameState.stats.great + gameState.stats.good + gameState.stats.miss;
      const accuracy = (gameState.stats.perfect * 1 + gameState.stats.great * 0.8 + gameState.stats.good * 0.5) / totalNotes;
      
      if (accuracy > 0.95) rating = "S";
      else if (accuracy > 0.9) rating = "A+";
      else if (accuracy > 0.8) rating = "A";
      else if (accuracy > 0.7) rating = "B";
      else if (accuracy > 0.6) rating = "C";
      else if (accuracy > 0.5) rating = "D";
      
      document.getElementById('rating').textContent = rating + " RANK";
      
      // Show results screen
      document.getElementById('results-screen').style.opacity = 1;
      document.getElementById('results-screen').style.pointerEvents = 'auto';
    }
    
    // Update notes
    function updateNotes() {
      const noteSpeed = gameState.difficultySettings[gameState.difficulty].noteSpeed * 
                       (gameState.specialMode ? 1.5 : 1);
      
      // Move notes
      for (const note of notes) {
        if (note.userData.active) {
          note.position.z += noteSpeed;
          
          // Check if note passed the target zone
          if (note.position.z > 3) {
            note.userData.active = false;
            note.userData.missed = true;
            notesToRemove.push(note);
            
            // Missing a note resets combo
            if (gameState.combo > 0) {
              gameState.combo = 0;
              gameState.multiplier = 1.0;
              gameState.stats.miss++;
              
              // Update UI
              document.getElementById("combo").textContent = `Combo: ${gameState.combo}`;
              document.getElementById("multiplier").textContent = `Multiplier: x${gameState.multiplier.toFixed(1)}`;
            }
          }
          
          // Rotate notes for visual effect
          note.rotation.x += 0.01;
          note.rotation.y += 0.01;
          
          // Scale effect for approaching notes
          if (note.position.z > -1 && note.position.z < 0) {
            const scale = 1 + (1 - Math.abs(note.position.z)) * 0.2;
            note.scale.set(scale, scale, scale);
          }
        }
      }
      
      // Remove notes marked for removal
      for (const note of notesToRemove) {
        const index = notes.indexOf(note);
        if (index !== -1) {
          scene.remove(note);
          notes.splice(index, 1);
        }
      }
      notesToRemove = [];
      
      // Add backup note generation to ensure notes always appear
      // Make sure we always have some notes in the game
      if (notes.length < 3 && gameState.isPlaying && !gameState.isPaused) {
        const laneIndex = Math.floor(Math.random() * gameState.difficultySettings[gameState.difficulty].laneCount);
        const isSpecial = Math.random() < 0.1;
        createNote(laneIndex, isSpecial);
      }
    }
  </script>
</body>
</html>